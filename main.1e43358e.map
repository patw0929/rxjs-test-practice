{"version":3,"sources":["../../src/util/root.ts","../../src/util/isFunction.ts","../../src/util/isArray.ts","../../src/util/isObject.ts","../../src/util/errorObject.ts","../../src/util/tryCatch.ts","../../src/util/UnsubscriptionError.ts","../src/Subscription.ts","../src/Observer.ts","../../src/symbol/rxSubscriber.ts","../src/Subscriber.ts","../../src/util/toSubscriber.ts","../../src/symbol/observable.ts","../../src/util/noop.ts","../../src/util/pipe.ts","../src/Observable.ts","../../src/observable/FromEventObservable.ts","../../src/observable/fromEvent.ts","../../../src/add/observable/fromEvent.ts","../../src/observable/PromiseObservable.ts","../../src/observable/fromPromise.ts","../../../src/add/observable/fromPromise.ts","../src/OuterSubscriber.ts","../../src/util/isArrayLike.ts","../../src/util/isPromise.ts","../../src/symbol/iterator.ts","../src/InnerSubscriber.ts","../../src/util/subscribeToResult.ts","../../src/operators/switchMap.ts","../../src/operator/switchMap.ts","../../../src/add/operator/switchMap.ts","../../src/scheduler/Action.ts","../../src/scheduler/AsyncAction.ts","../src/Scheduler.ts","../../src/scheduler/AsyncScheduler.ts","../../src/scheduler/async.ts","../../src/operators/debounceTime.ts","../../src/operator/debounceTime.ts","../../../src/add/operator/debounceTime.ts","../../src/operators/map.ts","../../src/operators/pluck.ts","../../src/operator/pluck.ts","../../../src/add/operator/pluck.ts","../../src/operator/map.ts","../../../src/add/operator/map.ts","../../src/operators/filter.ts","../../src/operator/filter.ts","../../../src/add/operator/filter.ts","src/utils.js","src/main.js"],"names":["fetchAPI","url","fetch","then","response","status","Error","json","total_count","items","map","item","name","full_name","searchRepo$","key$","fetch$","dueTime","scheduler","debounceTime","pluck","text","trim","filter","query","length","switchMap","createKeyup$","Observable","fromEvent","document","querySelector","fetchRepoList$","fromPromise","subscribe","value","innerHTML","repo","join"],"mappings":"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","file":"main.1e43358e.map","sourceRoot":"..","sourcesContent":["declare let global: any;\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\ndeclare var WorkerGlobalScope: any;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\n\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\nconst _root: any = __window || __global || __self;\n\n// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n// This is needed when used with angular/tsickle which inserts a goog.module statement.\n// Wrap in IIFE\n(function () {\n  if (!_root) {\n    throw new Error('RxJS could not find any global context (window, self, global)');\n  }\n})();\n\nexport { _root as root };","export function isFunction(x: any): x is Function {\n  return typeof x === 'function';\n}\n","export const isArray = Array.isArray || (<T>(x: any): x is T[] => x && typeof x.length === 'number');\n","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","// typeof any so that it we don't have to cast when comparing a result to the error object\nexport const errorObject: any = { e: {} };","import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n};\n","/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n  constructor(public errors: any[]) {\n    super();\n    const err: any = Error.call(this, errors ?\n      `${errors.length} errors occurred during unsubscription:\n  ${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '');\n    (<any> this).name = err.name = 'UnsubscriptionError';\n    (<any> this).stack = err.stack;\n    (<any> this).message = err.message;\n  }\n}\n","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\n\nexport interface AnonymousSubscription {\n  unsubscribe(): void;\n}\n\nexport type TeardownLogic = AnonymousSubscription | Function | void;\n\nexport interface ISubscription extends AnonymousSubscription {\n  unsubscribe(): void;\n  readonly closed: boolean;\n}\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements ISubscription {\n  public static EMPTY: Subscription = (function(empty: any){\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  protected _parent: Subscription = null;\n  protected _parents: Subscription[] = null;\n  private _subscriptions: ISubscription[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","export interface NextObserver<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface ErrorObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface CompletionObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete: () => void;\n}\n\nexport type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;\n\nexport interface Observer<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void { throw err; },\n  complete(): void { /*noop*/ }\n};\n","import { root } from '../util/root';\n\nconst Symbol: any = root.Symbol;\n\nexport const rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n  Symbol.for('rxSubscriber') : '@@rxSubscriber';\n\n/**\n * @deprecated use rxSubscriber instead\n */\nexport const $$rxSubscriber = rxSubscriber;\n","import { isFunction } from './util/isFunction';\nimport { Observer, PartialObserver } from './Observer';\nimport { Subscription } from './Subscription';\nimport { empty as emptyObserver } from './Observer';\nimport { rxSubscriber as rxSubscriberSymbol } from './symbol/rxSubscriber';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  public syncErrorValue: any = null;\n  public syncErrorThrown: boolean = false;\n  public syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          // HACK(benlesh): To resolve an issue where Node users may have multiple\n          // copies of rxjs in their node_modules directory.\n          if (isTrustedSubscriber(destinationOrNext)) {\n            const trustedSubscriber = destinationOrNext[rxSubscriberSymbol]() as Subscriber<any>;\n            this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;\n            this.destination = trustedSubscriber;\n            trustedSubscriber.add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached {@link Error}. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  /** @deprecated internal use only */ _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._error) {\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        throw err;\n      } else {\n        _parentSubscriber.syncErrorValue = err;\n        _parentSubscriber.syncErrorThrown = true;\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      throw err;\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      parent.syncErrorValue = err;\n      parent.syncErrorThrown = true;\n      return true;\n    }\n    return false;\n  }\n\n  /** @deprecated internal use only */ _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n\nfunction isTrustedSubscriber(obj: any) {\n  return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriberSymbol]);\n}\n","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { PartialObserver, empty as emptyObserver } from '../Observer';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { root } from '../util/root';\n\nexport function getSymbolObservable(context: any) {\n  let $$observable: any;\n  let Symbol = context.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (Symbol.observable) {\n      $$observable = Symbol.observable;\n    } else {\n        $$observable = Symbol('observable');\n        Symbol.observable = $$observable;\n    }\n  } else {\n    $$observable = '@@observable';\n  }\n\n  return $$observable;\n}\n\nexport const observable = getSymbolObservable(root);\n\n/**\n * @deprecated use observable instead\n */\nexport const $$observable = observable;\n","/* tslint:disable:no-empty */\nexport function noop() { }\n","import { noop } from './noop';\nimport { UnaryFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(): UnaryFunction<T, T>;\nexport function pipe<T, A>(op1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>, op9: UnaryFunction<H, I>): UnaryFunction<T, I>;\n/* tslint:enable:max-line-length */\n\nexport function pipe<T, R>(...fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  return pipeFromArray(fns);\n}\n\n/* @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input);\n  };\n}\n","import { PartialObserver } from './Observer';\nimport { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, AnonymousSubscription, TeardownLogic } from './Subscription';\nimport { root } from './util/root';\nimport { toSubscriber } from './util/toSubscriber';\nimport { IfObservable } from './observable/IfObservable';\nimport { ErrorObservable } from './observable/ErrorObservable';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { OperatorFunction } from './interfaces';\nimport { pipeFromArray } from './util/pipe';\n\nexport interface Subscribable<T> {\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): AnonymousSubscription;\n}\n\nexport type SubscribableOrPromise<T> = Subscribable<T> | PromiseLike<T>;\nexport type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T>;\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  public _isScalar: boolean = false;\n\n  /** @deprecated internal use only */ public source: Observable<any>;\n  protected operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n   * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n   * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n   * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n   *\n   * @example <caption>Subscribe with an Observer</caption>\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Subscribe with functions</caption>\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Cancel a subscription</caption>\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   *\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n    }\n\n    if (sink.syncErrorThrowable) {\n      sink.syncErrorThrowable = false;\n      if (sink.syncErrorThrown) {\n        throw sink.syncErrorValue;\n      }\n    }\n\n    return sink;\n  }\n\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      sink.syncErrorThrown = true;\n      sink.syncErrorValue = err;\n      sink.error(err);\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, PromiseCtor?: typeof Promise): Promise<void> {\n    if (!PromiseCtor) {\n      if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n        PromiseCtor = root.Rx.config.Promise;\n      } else if (root.Promise) {\n        PromiseCtor = root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        if (subscription) {\n          // if there is a subscription, then we can surmise\n          // the next handling is asynchronous. Any errors thrown\n          // need to be rejected explicitly and unsubscribe must be\n          // called manually\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscription.unsubscribe();\n          }\n        } else {\n          // if there is NO subscription, then we're getting a nexted\n          // value synchronously during subscription. We can just call it.\n          // If it errors, Observable's `subscribe` will ensure the\n          // unsubscription logic is called, then synchronously rethrow the error.\n          // After that, Promise will trap the error and send it\n          // down the rejection path.\n          next(value);\n        }\n      }, reject, resolve);\n    });\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words\n  static if: typeof IfObservable.create;\n  static throw: typeof ErrorObservable.create;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>\n  pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>\n  pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>\n  pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>\n  pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>\n  pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>\n  pipe<R>(...operations: OperatorFunction<T, R>[]): Observable<R>\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * @example\n   *\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   */\n  pipe<R>(...operations: OperatorFunction<T, R>[]): Observable<R> {\n    if (operations.length === 0) {\n      return this as any;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  toPromise<T>(this: Observable<T>): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n  /* tslint:enable:max-line-length */\n\n  toPromise(PromiseCtor?: PromiseConstructorLike) {\n    if (!PromiseCtor) {\n      if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n        PromiseCtor = root.Rx.config.Promise;\n      } else if (root.Promise) {\n        PromiseCtor = root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor((resolve, reject) => {\n      let value: any;\n      this.subscribe((x: T) => value = x, (err: any) => reject(err), () => resolve(value));\n    }) as Promise<T>;\n  }\n}\n","import { Observable } from '../Observable';\nimport { tryCatch } from '../util/tryCatch';\nimport { isFunction } from '../util/isFunction';\nimport { errorObject } from '../util/errorObject';\nimport { Subscription } from '../Subscription';\nimport { Subscriber } from '../Subscriber';\n\nconst toString: Function = Object.prototype.toString;\n\nexport type NodeStyleEventEmitter = {\n  addListener: (eventName: string, handler: NodeEventHandler) => void;\n  removeListener: (eventName: string, handler: NodeEventHandler) => void;\n};\n\nexport type NodeEventHandler = (...args: any[]) => void;\n\nfunction isNodeStyleEventEmitter(sourceObj: any): sourceObj is NodeStyleEventEmitter {\n  return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\n\nexport type JQueryStyleEventEmitter = {\n  on: (eventName: string, handler: Function) => void;\n  off: (eventName: string, handler: Function) => void;\n};\nfunction isJQueryStyleEventEmitter(sourceObj: any): sourceObj is JQueryStyleEventEmitter {\n  return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\n\nfunction isNodeList(sourceObj: any): sourceObj is NodeList {\n  return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n}\n\nfunction isHTMLCollection(sourceObj: any): sourceObj is HTMLCollection {\n  return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n}\n\nfunction isEventTarget(sourceObj: any): sourceObj is EventTarget {\n  return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n\nexport type EventTargetLike = EventTarget | NodeStyleEventEmitter | JQueryStyleEventEmitter | NodeList | HTMLCollection;\n\nexport type EventListenerOptions = {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n} | boolean;\n\nexport type SelectorMethodSignature<T> = (...args: Array<any>) => T;\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class FromEventObservable<T> extends Observable<T> {\n\n  /* tslint:disable:max-line-length */\n  static create<T>(target: EventTargetLike, eventName: string): Observable<T>;\n  static create<T>(target: EventTargetLike, eventName: string, selector: SelectorMethodSignature<T>): Observable<T>;\n  static create<T>(target: EventTargetLike, eventName: string, options: EventListenerOptions): Observable<T>;\n  static create<T>(target: EventTargetLike, eventName: string, options: EventListenerOptions, selector: SelectorMethodSignature<T>): Observable<T>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Creates an Observable that emits events of a specific type coming from the\n   * given event target.\n   *\n   * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n   * EventEmitter events or others.</span>\n   *\n   * <img src=\"./img/fromEvent.png\" width=\"100%\">\n   *\n   * `fromEvent` accepts as a first argument event target, which is an object with methods\n   * for registering event handler functions. As a second argument it takes string that indicates\n   * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n   * which are described in detail below. If your event target does not match any of the ones listed,\n   * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n   * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n   * handler functions have different names, but they all accept a string describing event type\n   * and function itself, which will be called whenever said event happens.\n   *\n   * Every time resulting Observable is subscribed, event handler function will be registered\n   * to event target on given event type. When that event fires, value\n   * passed as a first argument to registered function will be emitted by output Observable.\n   * When Observable is unsubscribed, function will be unregistered from event target.\n   *\n   * Note that if event target calls registered function with more than one argument, second\n   * and following arguments will not appear in resulting stream. In order to get access to them,\n   * you can pass to `fromEvent` optional project function, which will be called with all arguments\n   * passed to event handler. Output Observable will then emit value returned by project function,\n   * instead of the usual value.\n   *\n   * Remember that event targets listed below are checked via duck typing. It means that\n   * no matter what kind of object you have and no matter what environment you work in,\n   * you can safely use `fromEvent` on that object if it exposes described methods (provided\n   * of course they behave as was described above). So for example if Node.js library exposes\n   * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n   * a good choice.\n   *\n   * If the API you use is more callback then event handler oriented (subscribed\n   * callback function fires only once and thus there is no need to manually\n   * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n   * instead.\n   *\n   * `fromEvent` supports following types of event targets:\n   *\n   * **DOM EventTarget**\n   *\n   * This is an object with `addEventListener` and `removeEventListener` methods.\n   *\n   * In the browser, `addEventListener` accepts - apart from event type string and event\n   * handler function arguments - optional third parameter, which is either an object or boolean,\n   * both used for additional configuration how and when passed function will be called. When\n   * `fromEvent` is used with event target of that type, you can provide this values\n   * as third parameter as well.\n   *\n   * **Node.js EventEmitter**\n   *\n   * An object with `addListener` and `removeListener` methods.\n   *\n   * **JQuery-style event target**\n   *\n   * An object with `on` and `off` methods\n   *\n   * **DOM NodeList**\n   *\n   * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n   *\n   * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n   * it contains and install event handler function in every of them. When returned Observable\n   * is unsubscribed, function will be removed from all Nodes.\n   *\n   * **DOM HtmlCollection**\n   *\n   * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n   * installed and removed in each of elements.\n   *\n   *\n   * @example <caption>Emits clicks happening on the DOM document</caption>\n   * var clicks = Rx.Observable.fromEvent(document, 'click');\n   * clicks.subscribe(x => console.log(x));\n   *\n   * // Results in:\n   * // MouseEvent object logged to console every time a click\n   * // occurs on the document.\n   *\n   *\n   * @example <caption>Use addEventListener with capture option</caption>\n   * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n   *                                                                          // which will be passed to addEventListener\n   * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n   *\n   * clicksInDocument.subscribe(() => console.log('document'));\n   * clicksInDiv.subscribe(() => console.log('div'));\n   *\n   * // By default events bubble UP in DOM tree, so normally\n   * // when we would click on div in document\n   * // \"div\" would be logged first and then \"document\".\n   * // Since we specified optional `capture` option, document\n   * // will catch event when it goes DOWN DOM tree, so console\n   * // will log \"document\" and then \"div\".\n   *\n   * @see {@link bindCallback}\n   * @see {@link bindNodeCallback}\n   * @see {@link fromEventPattern}\n   *\n   * @param {EventTargetLike} target The DOM EventTarget, Node.js\n   * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n   * @param {string} eventName The event name of interest, being emitted by the\n   * `target`.\n   * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n   * @param {SelectorMethodSignature<T>} [selector] An optional function to\n   * post-process results. It takes the arguments from the event handler and\n   * should return a single value.\n   * @return {Observable<T>}\n   * @static true\n   * @name fromEvent\n   * @owner Observable\n   */\n  static create<T>(target: EventTargetLike,\n                   eventName: string,\n                   options?: EventListenerOptions | SelectorMethodSignature<T>,\n                   selector?: SelectorMethodSignature<T>): Observable<T> {\n    if (isFunction(options)) {\n      selector = <any>options;\n      options = undefined;\n    }\n    return new FromEventObservable(target, eventName, selector, options as EventListenerOptions | undefined);\n  }\n\n  constructor(private sourceObj: EventTargetLike,\n              private eventName: string,\n              private selector?: SelectorMethodSignature<T>,\n              private options?: EventListenerOptions) {\n    super();\n  }\n\n  private static setupSubscription<T>(sourceObj: EventTargetLike,\n                                      eventName: string,\n                                      handler: Function,\n                                      subscriber: Subscriber<T>,\n                                      options?: EventListenerOptions) {\n    let unsubscribe: () => void;\n    if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n      for (let i = 0, len = sourceObj.length; i < len; i++) {\n        FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n      }\n    } else if (isEventTarget(sourceObj)) {\n      const source = sourceObj;\n      sourceObj.addEventListener(eventName, <EventListener>handler, <boolean>options);\n      unsubscribe = () => source.removeEventListener(eventName, <EventListener>handler, <boolean>options);\n    } else if (isJQueryStyleEventEmitter(sourceObj)) {\n      const source = sourceObj;\n      sourceObj.on(eventName, handler);\n      unsubscribe = () => source.off(eventName, handler);\n    } else if (isNodeStyleEventEmitter(sourceObj)) {\n      const source = sourceObj;\n      sourceObj.addListener(eventName, handler as NodeEventHandler);\n      unsubscribe = () => source.removeListener(eventName, handler as NodeEventHandler);\n    } else {\n      throw new TypeError('Invalid event target');\n    }\n\n    subscriber.add(new Subscription(unsubscribe));\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>) {\n    const sourceObj = this.sourceObj;\n    const eventName = this.eventName;\n    const options = this.options;\n    const selector = this.selector;\n    let handler = selector ? (...args: any[]) => {\n      let result = tryCatch(selector)(...args);\n      if (result === errorObject) {\n        subscriber.error(errorObject.e);\n      } else {\n        subscriber.next(result);\n      }\n    } : (e: any) => subscriber.next(e);\n\n    FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n  }\n}\n","import {  FromEventObservable  } from './FromEventObservable';\n\nexport const fromEvent = FromEventObservable.create;","import { Observable } from '../../Observable';\nimport { fromEvent as staticFromEvent } from '../../observable/fromEvent';\n\nObservable.fromEvent = staticFromEvent;\n\ndeclare module '../../Observable' {\n  namespace Observable {\n    export let fromEvent: typeof staticFromEvent;\n  }\n}","import { root } from '../util/root';\nimport { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class PromiseObservable<T> extends Observable<T> {\n\n  public value: T;\n\n  /**\n   * Converts a Promise to an Observable.\n   *\n   * <span class=\"informal\">Returns an Observable that just emits the Promise's\n   * resolved value, then completes.</span>\n   *\n   * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n   * Observable. If the Promise resolves with a value, the output Observable\n   * emits that resolved value as a `next`, and then completes. If the Promise\n   * is rejected, then the output Observable emits the corresponding Error.\n   *\n   * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n   * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n   * result.subscribe(x => console.log(x), e => console.error(e));\n   *\n   * @see {@link bindCallback}\n   * @see {@link from}\n   *\n   * @param {PromiseLike<T>} promise The promise to be converted.\n   * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n   * the delivery of the resolved value (or the rejection).\n   * @return {Observable<T>} An Observable which wraps the Promise.\n   * @static true\n   * @name fromPromise\n   * @owner Observable\n   */\n  static create<T>(promise: PromiseLike<T>, scheduler?: IScheduler): Observable<T> {\n    return new PromiseObservable(promise, scheduler);\n  }\n\n  constructor(private promise: PromiseLike<T>, private scheduler?: IScheduler) {\n    super();\n  }\n\n  /** @deprecated internal use only */ _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    const promise = this.promise;\n    const scheduler = this.scheduler;\n\n    if (scheduler == null) {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          subscriber.next(this.value);\n          subscriber.complete();\n        }\n      } else {\n        promise.then(\n          (value) => {\n            this.value = value;\n            this._isScalar = true;\n            if (!subscriber.closed) {\n              subscriber.next(value);\n              subscriber.complete();\n            }\n          },\n          (err) => {\n            if (!subscriber.closed) {\n              subscriber.error(err);\n            }\n          }\n        )\n        .then(null, err => {\n          // escape the promise trap, throw unhandled errors\n          root.setTimeout(() => { throw err; });\n        });\n      }\n    } else {\n      if (this._isScalar) {\n        if (!subscriber.closed) {\n          return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber });\n        }\n      } else {\n        promise.then(\n          (value) => {\n            this.value = value;\n            this._isScalar = true;\n            if (!subscriber.closed) {\n              subscriber.add(scheduler.schedule(dispatchNext, 0, { value, subscriber }));\n            }\n          },\n          (err) => {\n            if (!subscriber.closed) {\n              subscriber.add(scheduler.schedule(dispatchError, 0, { err, subscriber }));\n            }\n          })\n          .then(null, (err) => {\n            // escape the promise trap, throw unhandled errors\n            root.setTimeout(() => { throw err; });\n          });\n      }\n    }\n  }\n}\n\ninterface DispatchNextArg<T> {\n  subscriber: Subscriber<T>;\n  value: T;\n}\nfunction dispatchNext<T>(arg: DispatchNextArg<T>) {\n  const { value, subscriber } = arg;\n  if (!subscriber.closed) {\n    subscriber.next(value);\n    subscriber.complete();\n  }\n}\n\ninterface DispatchErrorArg<T> {\n  subscriber: Subscriber<T>;\n  err: any;\n}\nfunction dispatchError<T>(arg: DispatchErrorArg<T>) {\n  const { err, subscriber } = arg;\n  if (!subscriber.closed) {\n    subscriber.error(err);\n  }\n}\n","import {  PromiseObservable  } from './PromiseObservable';\n\nexport const fromPromise = PromiseObservable.create;","import { Observable } from '../../Observable';\nimport { fromPromise as staticFromPromise } from '../../observable/fromPromise';\n\nObservable.fromPromise = staticFromPromise;\n\ndeclare module '../../Observable' {\n  namespace Observable {\n    export let fromPromise: typeof staticFromPromise;\n  }\n}","import { Subscriber } from './Subscriber';\nimport { InnerSubscriber } from './InnerSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class OuterSubscriber<T, R> extends Subscriber<T> {\n  notifyNext(outerValue: T, innerValue: R,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, R>): void {\n    this.destination.next(innerValue);\n  }\n\n  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void {\n    this.destination.error(error);\n  }\n\n  notifyComplete(innerSub: InnerSubscriber<T, R>): void {\n    this.destination.complete();\n  }\n}\n","export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number');","export function isPromise<T>(value: any | Promise<T>): value is Promise<T> {\n  return value && typeof (<any>value).subscribe !== 'function' && typeof (value as any).then === 'function';\n}\n","import { root } from '../util/root';\n\nexport function symbolIteratorPonyfill(root: any) {\n  const Symbol: any = root.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (!Symbol.iterator) {\n      Symbol.iterator = Symbol('iterator polyfill');\n    }\n    return Symbol.iterator;\n  } else {\n    // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n    const { Set } = root;\n    if (Set && typeof new Set()['@@iterator'] === 'function') {\n      return '@@iterator';\n    }\n    const { Map } = root;\n    // required for compatability with es6-shim\n    if (Map) {\n      let keys = Object.getOwnPropertyNames(Map.prototype);\n      for (let i = 0; i < keys.length; ++i) {\n        let key = keys[i];\n        // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n        if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {\n          return key;\n        }\n      }\n    }\n    return '@@iterator';\n  }\n}\n\nexport const iterator = symbolIteratorPonyfill(root);\n\n/**\n * @deprecated use iterator instead\n */\nexport const $$iterator = iterator;\n","import { Subscriber } from './Subscriber';\nimport { OuterSubscriber } from './OuterSubscriber';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class InnerSubscriber<T, R> extends Subscriber<R> {\n  private index: number = 0;\n\n  constructor(private parent: OuterSubscriber<T, R>, private outerValue: T, private outerIndex: number) {\n    super();\n  }\n\n  protected _next(value: R): void {\n    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n  }\n\n  protected _error(error: any): void {\n    this.parent.notifyError(error, this);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.parent.notifyComplete(this);\n    this.unsubscribe();\n  }\n}\n","import { root } from './root';\nimport { isArrayLike } from './isArrayLike';\nimport { isPromise } from './isPromise';\nimport { isObject } from './isObject';\nimport { Subscriber } from '../Subscriber';\nimport { Observable, ObservableInput } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { Subscription } from '../Subscription';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function subscribeToResult<T, R>(outerSubscriber: OuterSubscriber<T, R>,\n                                        result: any,\n                                        outerValue?: T,\n                                        outerIndex?: number): Subscription;\nexport function subscribeToResult<T>(outerSubscriber: OuterSubscriber<any, any>,\n                                     result: ObservableInput<T>,\n                                     outerValue?: T,\n                                     outerIndex?: number): Subscription {\n  let destination: Subscriber<any> = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n\n  if (destination.closed) {\n    return null;\n  }\n\n  if (result instanceof Observable) {\n    if (result._isScalar) {\n      destination.next((<any>result).value);\n      destination.complete();\n      return null;\n    } else {\n      destination.syncErrorThrowable = true;\n      return result.subscribe(destination);\n    }\n  } else if (isArrayLike(result)) {\n    for (let i = 0, len = result.length; i < len && !destination.closed; i++) {\n      destination.next(result[i]);\n    }\n    if (!destination.closed) {\n      destination.complete();\n    }\n  } else if (isPromise(result)) {\n    result.then(\n      (value) => {\n        if (!destination.closed) {\n          destination.next(<any>value);\n          destination.complete();\n        }\n      },\n      (err: any) => destination.error(err)\n    )\n    .then(null, (err: any) => {\n      // Escaping the Promise trap: globally throw unhandled errors\n      root.setTimeout(() => { throw err; });\n    });\n    return destination;\n  } else if (result && typeof result[Symbol_iterator] === 'function') {\n    const iterator = <any>result[Symbol_iterator]();\n    do {\n      let item = iterator.next();\n      if (item.done) {\n        destination.complete();\n        break;\n      }\n      destination.next(item.value);\n      if (destination.closed) {\n        break;\n      }\n    } while (true);\n  } else if (result && typeof result[Symbol_observable] === 'function') {\n    const obs = result[Symbol_observable]();\n    if (typeof obs.subscribe !== 'function') {\n      destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n    } else {\n      return obs.subscribe(new InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n    }\n  } else {\n    const value = isObject(result) ? 'an invalid object' : `'${result}'`;\n    const msg = `You provided ${value} where a stream was expected.`\n      + ' You can provide an Observable, Promise, Array, or Iterable.';\n    destination.error(new TypeError(msg));\n  }\n  return null;\n}\n","import { Operator } from '../Operator';\nimport { Observable, ObservableInput } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, R>(project: (value: T, index: number) => ObservableInput<R>): OperatorFunction<T, R>;\nexport function switchMap<T, I, R>(project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nexport function switchMap<T, I, R>(\n  project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, I | R> {\n  return function switchMapOperatorFunction(source: Observable<T>): Observable<I | R> {\n    return source.lift(new SwitchMapOperator(project, resultSelector));\n  };\n}\n\nclass SwitchMapOperator<T, I, R> implements Operator<T, I> {\n  constructor(private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n  }\n\n  call(subscriber: Subscriber<I>, source: any): any {\n    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SwitchMapSubscriber<T, I, R> extends OuterSubscriber<T, I> {\n  private index: number = 0;\n  private innerSubscription: Subscription;\n\n  constructor(destination: Subscriber<I>,\n              private project: (value: T, index: number) => ObservableInput<I>,\n              private resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    let result: ObservableInput<I>;\n    const index = this.index++;\n    try {\n      result = this.project(value, index);\n    } catch (error) {\n      this.destination.error(error);\n      return;\n    }\n    this._innerSub(result, value, index);\n  }\n\n  private _innerSub(result: ObservableInput<I>, value: T, index: number) {\n    const innerSubscription = this.innerSubscription;\n    if (innerSubscription) {\n      innerSubscription.unsubscribe();\n    }\n    this.add(this.innerSubscription = subscribeToResult(this, result, value, index));\n  }\n\n  protected _complete(): void {\n    const {innerSubscription} = this;\n    if (!innerSubscription || innerSubscription.closed) {\n      super._complete();\n    }\n  }\n\n  /** @deprecated internal use only */ _unsubscribe() {\n    this.innerSubscription = null;\n  }\n\n  notifyComplete(innerSub: Subscription): void {\n    this.remove(innerSub);\n    this.innerSubscription = null;\n    if (this.isStopped) {\n      super._complete();\n    }\n  }\n\n  notifyNext(outerValue: T, innerValue: I,\n             outerIndex: number, innerIndex: number,\n             innerSub: InnerSubscriber<T, I>): void {\n    if (this.resultSelector) {\n      this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n    } else {\n      this.destination.next(innerValue);\n    }\n  }\n\n  private _tryNotifyNext(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): void {\n    let result: R;\n    try {\n      result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","\nimport { Observable, ObservableInput } from '../Observable';\nimport { switchMap as higherOrderSwitchMap } from '../operators/switchMap';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, R>(this: Observable<T>, project: (value: T, index: number) => ObservableInput<R>): Observable<R>;\nexport function switchMap<T, I, R>(this: Observable<T>, project: (value: T, index: number) => ObservableInput<I>, resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switch}.</span>\n *\n * <img src=\"./img/switchMap.png\" width=\"100%\">\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * @example <caption>Rerun an interval Observable on every click event</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n * result.subscribe(x => console.log(x));\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switch}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n * A function to produce the value on the output Observable based on the values\n * and the indices of the source (outer) emission and the inner Observable\n * emission. The arguments passed to this function are:\n * - `outerValue`: the value that came from the source\n * - `innerValue`: the value that came from the projected Observable\n * - `outerIndex`: the \"index\" of the value that came from the source\n * - `innerIndex`: the \"index\" of the value from the projected Observable\n * @return {Observable} An Observable that emits the result of applying the\n * projection function (and the optional `resultSelector`) to each item emitted\n * by the source Observable and taking only the values from the most recently\n * projected inner Observable.\n * @method switchMap\n * @owner Observable\n */\nexport function switchMap<T, I, R>(this: Observable<T>, project: (value: T, index: number) => ObservableInput<I>,\n                                   resultSelector?: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable<I | R> {\n  return higherOrderSwitchMap(project, resultSelector)(this);\n}\n","\nimport { Observable } from '../../Observable';\nimport { switchMap } from '../../operator/switchMap';\n\nObservable.prototype.switchMap = switchMap;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    switchMap: typeof switchMap;\n  }\n}","import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\n\n/**\n * A unit of work to be executed in a {@link Scheduler}. An action is typically\n * created from within a Scheduler and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: Action<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent Scheduler for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n","import { root } from '../util/root';\nimport { Action } from './Action';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nexport class AsyncAction<T> extends Action<T> {\n\n  public id: any;\n  public state: T;\n  public delay: number;\n  protected pending: boolean = false;\n  protected work: (this: this, state?: T) => void;\n\n  constructor(protected scheduler: AsyncScheduler,\n              work: (this: AsyncAction<T>, state?: T) => void) {\n    super(scheduler, work);\n    this.work = work;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n\n    if (this.closed) {\n      return this;\n     }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any {\n    return root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    return root.clearInterval(id) && undefined || undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any = undefined;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  /** @deprecated internal use only */ _unsubscribe() {\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n    const actions = scheduler.actions;\n    const index = actions.indexOf(this);\n\n    this.work  = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  }\n}\n","import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\n\nexport interface IScheduler {\n  now(): number;\n  schedule<T>(work: (this: Action<T>, state?: T) => void, delay?: number, state?: T): Subscription;\n}\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an {@link Action}.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n */\nexport class Scheduler implements IScheduler {\n\n  public static now: () => number = Date.now ? Date.now : () => +new Date();\n\n  constructor(private SchedulerAction: typeof Action,\n              now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: Action<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.SchedulerAction<T>(this, work).schedule(state, delay);\n  }\n}\n","import { Scheduler } from '../Scheduler';\nimport { AsyncAction } from './AsyncAction';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   */\n  public active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   */\n  public scheduled: any = undefined;\n\n  public flush(action: AsyncAction<any>): void {\n\n    const {actions} = this;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift()); // exhaust the scheduler queue\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n","import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asap} scheduler.\n *\n * @example <caption>Use async scheduler to delay task</caption>\n * const task = () => console.log('it works!');\n *\n * Rx.Scheduler.async.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n *\n *\n * @example <caption>Use async scheduler to repeat task in intervals</caption>\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * Rx.Scheduler.async.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n *\n * @static true\n * @name async\n * @owner Scheduler\n */\n\nexport const async = new AsyncScheduler(AsyncAction);\n","import { Operator } from '../Operator';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { IScheduler } from '../Scheduler';\nimport { Subscription, TeardownLogic } from '../Subscription';\nimport { async } from '../scheduler/async';\nimport { MonoTypeOperatorFunction } from '../interfaces';\n\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nexport function debounceTime<T>(dueTime: number, scheduler: IScheduler = async): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => source.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\n\nclass DebounceTimeOperator<T> implements Operator<T, T> {\n  constructor(private dueTime: number, private scheduler: IScheduler) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass DebounceTimeSubscriber<T> extends Subscriber<T> {\n  private debouncedSubscription: Subscription = null;\n  private lastValue: T = null;\n  private hasValue: boolean = false;\n\n  constructor(destination: Subscriber<T>,\n              private dueTime: number,\n              private scheduler: IScheduler) {\n    super(destination);\n  }\n\n  protected _next(value: T) {\n    this.clearDebounce();\n    this.lastValue = value;\n    this.hasValue = true;\n    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n  }\n\n  protected _complete() {\n    this.debouncedNext();\n    this.destination.complete();\n  }\n\n  debouncedNext(): void {\n    this.clearDebounce();\n\n    if (this.hasValue) {\n      this.destination.next(this.lastValue);\n      this.lastValue = null;\n      this.hasValue = false;\n    }\n  }\n\n  private clearDebounce(): void {\n    const debouncedSubscription = this.debouncedSubscription;\n\n    if (debouncedSubscription !== null) {\n      this.remove(debouncedSubscription);\n      debouncedSubscription.unsubscribe();\n      this.debouncedSubscription = null;\n    }\n  }\n}\n\nfunction dispatchNext(subscriber: DebounceTimeSubscriber<any>) {\n  subscriber.debouncedNext();\n}\n","\nimport { Observable } from '../Observable';\nimport { IScheduler } from '../Scheduler';\nimport { async } from '../scheduler/async';\nimport { debounceTime as higherOrder } from '../operators/debounceTime';\n\n/**\n * Emits a value from the source Observable only after a particular time span\n * has passed without another source emission.\n *\n * <span class=\"informal\">It's like {@link delay}, but passes only the most\n * recent value from each burst of emissions.</span>\n *\n * <img src=\"./img/debounceTime.png\" width=\"100%\">\n *\n * `debounceTime` delays values emitted by the source Observable, but drops\n * previous pending delayed emissions if a new value arrives on the source\n * Observable. This operator keeps track of the most recent value from the\n * source Observable, and emits that only when `dueTime` enough time has passed\n * without any other value appearing on the source Observable. If a new value\n * appears before `dueTime` silence occurs, the previous value will be dropped\n * and will not be emitted on the output Observable.\n *\n * This is a rate-limiting operator, because it is impossible for more than one\n * value to be emitted in any time window of duration `dueTime`, but it is also\n * a delay-like operator since output emissions do not occur at the same time as\n * they did on the source Observable. Optionally takes a {@link IScheduler} for\n * managing timers.\n *\n * @example <caption>Emit the most recent click after a burst of clicks</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var result = clicks.debounceTime(1000);\n * result.subscribe(x => console.log(x));\n *\n * @see {@link auditTime}\n * @see {@link debounce}\n * @see {@link delay}\n * @see {@link sampleTime}\n * @see {@link throttleTime}\n *\n * @param {number} dueTime The timeout duration in milliseconds (or the time\n * unit determined internally by the optional `scheduler`) for the window of\n * time required to wait for emission silence before emitting the most recent\n * source value.\n * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n * managing the timers that handle the timeout for each value.\n * @return {Observable} An Observable that delays the emissions of the source\n * Observable by the specified `dueTime`, and may drop some values if they occur\n * too frequently.\n * @method debounceTime\n * @owner Observable\n */\nexport function debounceTime<T>(this: Observable<T>, dueTime: number, scheduler: IScheduler = async): Observable<T> {\n  return higherOrder(dueTime, scheduler)(this) as Observable<T>;\n}\n","\nimport { Observable } from '../../Observable';\nimport { debounceTime } from '../../operator/debounceTime';\n\nObservable.prototype.debounceTime = debounceTime;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    debounceTime: typeof debounceTime;\n  }\n}","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return function mapOperation(source: Observable<T>): Observable<R> {\n    if (typeof project !== 'function') {\n      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return source.lift(new MapOperator(project, thisArg));\n  };\n}\n\nexport class MapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => R, private thisArg: any) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapSubscriber<T, R> extends Subscriber<T> {\n  count: number = 0;\n  private thisArg: any;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => R,\n              thisArg: any) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  // NOTE: This looks unoptimized, but it's actually purposefully NOT\n  // using try/catch optimizations.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.project.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","import { Observable } from '../Observable';\nimport { map } from './map';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * <img src=\"./img/pluck.png\" width=\"100%\">\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * @example <caption>Map every click to the tagName of the clicked target element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var tagNames = clicks.pluck('target', 'tagName');\n * tagNames.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} A new Observable of property values from the source values.\n * @method pluck\n * @owner Observable\n */\nexport function pluck<T, R>(...properties: string[]): OperatorFunction<T, R> {\n  const length = properties.length;\n  if (length === 0) {\n    throw new Error('list of properties cannot be empty.');\n  }\n  return (source: Observable<T>) => map(plucker(properties, length))(source as any);\n}\n\nfunction plucker(props: string[], length: number): (x: string) => any {\n  const mapper = (x: string) => {\n    let currentProp = x;\n    for (let i = 0; i < length; i++) {\n      const p = currentProp[props[i]];\n      if (typeof p !== 'undefined') {\n        currentProp = p;\n      } else {\n        return undefined;\n      }\n    }\n    return currentProp;\n  };\n\n  return mapper;\n}\n","import { Observable } from '../Observable';\nimport { pluck as higherOrder } from '../operators/pluck';\n\n/**\n * Maps each source value (an object) to its specified nested property.\n *\n * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n * the nested properties of every emitted object.</span>\n *\n * <img src=\"./img/pluck.png\" width=\"100%\">\n *\n * Given a list of strings describing a path to an object property, retrieves\n * the value of a specified nested property from all values in the source\n * Observable. If a property can't be resolved, it will return `undefined` for\n * that value.\n *\n * @example <caption>Map every click to the tagName of the clicked target element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var tagNames = clicks.pluck('target', 'tagName');\n * tagNames.subscribe(x => console.log(x));\n *\n * @see {@link map}\n *\n * @param {...string} properties The nested properties to pluck from each source\n * value (an object).\n * @return {Observable} A new Observable of property values from the source values.\n * @method pluck\n * @owner Observable\n */\nexport function pluck<T, R>(this: Observable<T>, ...properties: string[]): Observable<R> {\n  return higherOrder(...properties)(this) as Observable<R>;\n}\n","\nimport { Observable } from '../../Observable';\nimport { pluck } from '../../operator/pluck';\n\nObservable.prototype.pluck = pluck;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    pluck: typeof pluck;\n  }\n}","import { map as higherOrderMap } from '../operators/map';\nimport { Observable } from '../Observable';\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map<T, R>(this: Observable<T>, project: (value: T, index: number) => R, thisArg?: any): Observable<R> {\n  return higherOrderMap(project, thisArg)(this);\n}\n","\nimport { Observable } from '../../Observable';\nimport { map } from '../../operator/map';\n\nObservable.prototype.map = map;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    map: typeof map;\n  }\n}","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\nimport { OperatorFunction, MonoTypeOperatorFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S,\n                                       thisArg?: any): OperatorFunction<T, S>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): MonoTypeOperatorFunction<T> {\n  return function filterOperatorFunction(source: Observable<T>): Observable<T> {\n    return source.lift(new FilterOperator(predicate, thisArg));\n  };\n}\n\nclass FilterOperator<T> implements Operator<T, T> {\n  constructor(private predicate: (value: T, index: number) => boolean,\n              private thisArg?: any) {\n  }\n\n  call(subscriber: Subscriber<T>, source: any): TeardownLogic {\n    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass FilterSubscriber<T> extends Subscriber<T> {\n\n  count: number = 0;\n\n  constructor(destination: Subscriber<T>,\n              private predicate: (value: T, index: number) => boolean,\n              private thisArg: any) {\n    super(destination);\n  }\n\n  // the try catch block below is left specifically for\n  // optimization and perf reasons. a tryCatcher is not necessary here.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.predicate.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    if (result) {\n      this.destination.next(value);\n    }\n  }\n}","\nimport { Observable } from '../Observable';\nimport { filter as higherOrderFilter } from '../operators/filter';\n\n/* tslint:disable:max-line-length */\nexport function filter<T, S extends T>(this: Observable<T>,\n                                       predicate: (value: T, index: number) => value is S,\n                                       thisArg?: any): Observable<S>;\nexport function filter<T>(this: Observable<T>,\n                          predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): Observable<T>;\n/* tslint:enable:max-line-length */\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * <img src=\"./img/filter.png\" width=\"100%\">\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * @example <caption>Emit only click events whose target was a DIV element</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n * clicksOnDivs.subscribe(x => console.log(x));\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param {function(value: T, index: number): boolean} predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param {any} [thisArg] An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return {Observable} An Observable of values from the source that were\n * allowed by the `predicate` function.\n * @method filter\n * @owner Observable\n */\nexport function filter<T>(this: Observable<T>, predicate: (value: T, index: number) => boolean,\n                          thisArg?: any): Observable<T> {\n  return higherOrderFilter(predicate, thisArg)(this);\n}\n","\nimport { Observable } from '../../Observable';\nimport { filter } from '../../operator/filter';\n\nObservable.prototype.filter = filter;\n\ndeclare module '../../Observable' {\n  interface Observable<T> {\n    filter: typeof filter;\n  }\n}","import { Observable } from 'rxjs/Observable';\nimport { fromEvent } from 'rxjs/add/observable/fromEvent';\nimport { fromPromise } from 'rxjs/add/observable/fromPromise';\nimport { switchMap } from 'rxjs/add/operator/switchMap';\nimport { debounceTime } from 'rxjs/add/operator/debounceTime';\nimport { pluck } from 'rxjs/add/operator/pluck';\nimport { map } from 'rxjs/add/operator/map';\nimport { filter } from 'rxjs/add/operator/filter';\n\nconst fetchAPI = url => {\n  return fetch(url)\n    .then(response => {\n      if (response.status !== 200) {\n        throw new Error('Invalid status');\n      }\n\n      return response.json();\n    })\n    .then(json => {\n      return {\n        total_count: json.total_count,\n        items: json.items.map(item => {\n          return {\n            name: item.name,\n            full_name: item.full_name,\n          };\n        }),\n      };\n    });\n};\n\nconst searchRepo$ = (key$, fetch$, dueTime, scheduler) => {\n  return key$.debounceTime(dueTime, scheduler)\n    .pluck('target', 'value')\n    .map(text => text.trim())\n    .filter(query => query.length !== 0)\n    .switchMap(fetch$);\n};\n\nconst createKeyup$ = () => Observable.fromEvent(\n  document.querySelector('#search-input'),\n  'keyup'\n);\n\nconst fetchRepoList$ = query => {\n  const url = `https://api.github.com/search/repositories?q=${query}&sort=stars&order=desc`;\n\n  return Observable.fromPromise(fetchAPI(url));\n};\n\nexport {\n  searchRepo$,\n  fetchRepoList$,\n  createKeyup$,\n};\n","import { Observable } from 'rxjs/Observable';\nimport { searchRepo$, fetchRepoList$, createKeyup$ } from './utils';\n\nsearchRepo$(createKeyup$(), fetchRepoList$, 150).subscribe(value => {\n  return document.querySelector('#results').innerHTML = value.items.map(\n    repo => `<li class=\"list-group-item\">${repo.full_name}</li>`\n  ).join('');\n});\n"]}